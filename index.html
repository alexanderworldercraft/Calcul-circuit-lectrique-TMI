<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Calculateur de circuits</title>
    <style>
        body {
            font-family: Arial;
            padding: 20px;
            background: #f9f9f9;
        }

        h1 {
            color: #333;
        }

        .section {
            margin-bottom: 20px;
        }

        label,
        input,
        button {
            margin: 5px;
        }

        input {
            width: 80px;
        }

        .results {
            margin-top: 20px;
            background: #fff;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .parallel-group {
            margin-bottom: 10px;
            border: 1px solid #ccc;
            padding: 10px;
        }
    </style>
</head>

<body>

    <h1>üßÆ Calculateur de circuits √©lectriques</h1>

    <div class="section">
        <label>Tension U (Volts) :</label>
        <input type="number" id="tension" placeholder="ex: 24">
    </div>

    <div class="section">
        <h2>üîó R√©sistances en s√©rie</h2>
        <div id="serieInputs"></div>
        <button onclick="addResistance('serie')">+ Ajouter r√©sistance s√©rie</button>
    </div>

    <div class="section">
        <h2>‚õìÔ∏è Zones en parall√®le</h2>
        <div id="parallelGroups">
            <div class="parallel-group" id="group1">
                <h3>Groupe 1</h3>
                <div id="paralleleInputs1"></div>
                <button onclick="addResistance('parallele', 1)">+ Ajouter r√©sistance parall√®le</button>
            </div>
        </div>
        <button onclick="addParallelGroup()">+ Ajouter un autre groupe parall√®le</button>
    </div>

    <div class="section">
        <button onclick="calculer()">‚ö° Calculer</button>
        <button onclick="reset()">üîÑ R√©initialiser</button>
    </div>

    <div class="results" id="resultats"></div>

    <h3>üß∞ Sch√©ma du circuit (sch√©ma logique)</h3>
    <canvas id="schemaCanvas" width="1000" height="300" style="border:1px solid #ccc;"></canvas>

    <script>
        // Ajout de champs dynamiques pour les r√©sistances
        function addResistance(type, groupId = 0) {
            const container = groupId > 0
                ? document.getElementById('paralleleInputs' + groupId)
                : document.getElementById('serieInputs');
            const input = document.createElement('input');
            input.type = 'number';
            input.placeholder = 'R en Œ©';
            input.className = type;
            container.appendChild(input);
        }

        // Ajout d'un groupe parall√®le
        function addParallelGroup() {
            const groupCount = document.querySelectorAll('.parallel-group').length + 1;
            const groupDiv = document.createElement('div');
            groupDiv.className = 'parallel-group';
            groupDiv.id = 'group' + groupCount;
            groupDiv.innerHTML = `
      <h3>Groupe ${groupCount}</h3>
      <div id="paralleleInputs${groupCount}"></div>
      <button onclick="addResistance('parallele', ${groupCount})">+ Ajouter r√©sistance parall√®le</button>
    `;
            document.getElementById('parallelGroups').appendChild(groupDiv);
        }

        // Fonction de calcul
        function calculer() {
            const U = parseFloat(document.getElementById('tension').value) || 0;

            const Rs = [...document.querySelectorAll('.serie')].map(el => parseFloat(el.value)).filter(v => !isNaN(v));
            const ReqSerie = Rs.reduce((acc, val) => acc + val, 0);

            const parallelGroups = document.querySelectorAll('.parallel-group');
            const allReqParalleles = [];

            // Calcul des Req de chaque groupe parall√®le
            parallelGroups.forEach(group => {
                const Rp = [...group.querySelectorAll('.parallele')].map(el => parseFloat(el.value)).filter(v => !isNaN(v));
                if (Rp.length > 0) {
                    const ReqParallele = 1 / Rp.reduce((acc, val) => acc + (1 / val), 0);
                    allReqParalleles.push({ Req: ReqParallele, Rp });
                }
            });

            const ReqTotal = ReqSerie + allReqParalleles.reduce((acc, g) => acc + g.Req, 0);
            const I_total = ReqTotal > 0 ? (U / ReqTotal) : 0;

            const Us_serie = Rs.map(R => (I_total * R).toFixed(2));

            let results = `
    <p><strong>R√©sistance √©quivalente totale :</strong> ${ReqTotal.toFixed(3)} Œ©</p>
    <p><strong>Courant total :</strong> ${I_total.toFixed(3)} A</p>
    <p><strong>Puissance totale :</strong> ${(U * I_total).toFixed(2)} W</p>
  `;

            if (Rs.length) {
                results += `<p><strong>R√©sistances en s√©rie :</strong></p><ul>`;
                Rs.forEach((R, i) => {
                    const U_R = I_total * R;
                    const P_R = U_R * I_total;
                    results += `<li>R${i + 1} = ${R} Œ© ‚Üí U = ${U_R.toFixed(2)} V, I = ${I_total.toFixed(2)} A, P = ${P_R.toFixed(2)} W</li>`;
                });
                results += `</ul>`;
            }

            // Affichage des groupes parall√®les avec calcul correct de U_groupe
            let tensionConsomm√©e = Rs.reduce((acc, R) => acc + (I_total * R), 0);
            allReqParalleles.forEach((groupe, idx) => {
                const U_groupe = I_total * groupe.Req;
                tensionConsomm√©e += U_groupe;

                results += `<p><strong>Groupe ${idx + 1} en parall√®le :</strong> (Req = ${groupe.Req.toFixed(3)} Œ©, U = ${U_groupe.toFixed(2)} V)</p><ul>`;

                groupe.Rp.forEach((R, i) => {
                    const I_R = U_groupe / R;
                    const P_R = I_R * U_groupe;
                    results += `<li>R${i + 1} = ${R} Œ© ‚Üí U = ${U_groupe.toFixed(2)} V, I = ${I_R.toFixed(2)} A, P = ${P_R.toFixed(2)} W</li>`;
                });

                results += `</ul>`;
            });

            dessinerSchemaAvecFabric(Rs, parallelGroups);

            document.getElementById('resultats').innerHTML = results;
        }


        // Fonction pour r√©initialiser tous les champs
        function reset() {
            // R√©initialisation des champs de tension et r√©sistances
            document.getElementById('tension').value = '';
            document.getElementById('serieInputs').innerHTML = '';
            document.getElementById('parallelGroups').innerHTML = `
      <div class="parallel-group" id="group1">
        <h3>Groupe 1</h3>
        <div id="paralleleInputs1"></div>
        <button onclick="addResistance('parallele', 1)">+ Ajouter r√©sistance parall√®le</button>
      </div>
    `;
            // R√©initialisation des r√©sultats
            document.getElementById('resultats').innerHTML = '';
        }

        function dessinerSchemaAvecFabric(Rs, parallelGroups) {
            const canvas = new fabric.Canvas('schemaCanvas');
            canvas.clear();

            let x = 50;
            const y = 100;
            const spacing = 100;

            // G√©n√©rateur
            canvas.add(new fabric.Rect({ left: x, top: y - 25, width: 20, height: 50, fill: 'lightblue' }));
            canvas.add(new fabric.Text('U', { left: x + 5, top: y - 10, fontSize: 16 }));
            x += 30;

            // R√©sistances s√©rie
            Rs.forEach((R, i) => {
                canvas.add(new fabric.Rect({ left: x, top: y - 20, width: 40, height: 40, fill: 'orange' }));
                canvas.add(new fabric.Text(`R${i + 1}`, { left: x + 5, top: y - 5, fontSize: 14 }));
                x += spacing;
            });

            // Groupes en parall√®le
            parallelGroups.forEach((group, groupIndex) => {
                const resistances = [...group.querySelectorAll('.parallele')]
                    .map(el => parseFloat(el.value))
                    .filter(v => !isNaN(v));

                if (!resistances.length) return;

                const branchStartX = x;
                const branchTopY = y - 60;
                const branchBottomY = y + 60;

                // Lignes de branchement
                canvas.add(new fabric.Line([x, y, x, branchTopY], { stroke: 'black' }));
                canvas.add(new fabric.Line([x, y, x, branchBottomY], { stroke: 'black' }));

                // Chaque r√©sistance en parall√®le
                resistances.forEach((R, j) => {
                    const yOffset = branchTopY + j * 40;
                    canvas.add(new fabric.Rect({ left: x + 30, top: yOffset, width: 40, height: 30, fill: 'lightgreen' }));
                    canvas.add(new fabric.Text(`G${groupIndex + 1}-R${j + 1}`, { left: x + 35, top: yOffset + 7, fontSize: 12 }));
                    canvas.add(new fabric.Line([x, yOffset + 15, x + 30, yOffset + 15], { stroke: 'black' }));
                    canvas.add(new fabric.Line([x + 70, yOffset + 15, x + 100, yOffset + 15], { stroke: 'black' }));
                });

                // Rejoint la ligne principale
                canvas.add(new fabric.Line([x + 100, branchTopY, x + 100, y], { stroke: 'black' }));
                canvas.add(new fabric.Line([x + 100, branchBottomY, x + 100, y], { stroke: 'black' }));

                x += 130;
            });

            // Fermeture du circuit
            canvas.add(new fabric.Line([x, y, x + 50, y], { stroke: 'black' }));
            canvas.add(new fabric.Text('GND', { left: x + 55, top: y - 10, fontSize: 14 }));
        }

    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

</body>

</html>
